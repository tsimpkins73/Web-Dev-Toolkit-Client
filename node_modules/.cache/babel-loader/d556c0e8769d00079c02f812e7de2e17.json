{"ast":null,"code":"import TokenService from './token-service';\nimport IdleService from './idle-service';\nimport { API_BASE_URL } from '../config';\nconst UserService = {\n  postUser(user) {\n    return fetch(\"\".concat(API_BASE_URL, \"/users\"), {\n      method: 'POST',\n      headers: {\n        'content-type': 'application/json'\n      },\n      body: JSON.stringify(user)\n    }).then(res => !res.ok ? res.json().then(e => Promise.reject(e)) : res.json());\n  },\n\n  postLogin({\n    username,\n    password\n  }) {\n    return fetch(\"\".concat(API_BASE_URL, \"/auth/login\"), {\n      method: 'POST',\n      headers: {\n        'content-type': 'application/json'\n      },\n      body: JSON.stringify({\n        username,\n        password\n      })\n    }).then(res => !res.ok ? res.json().then(e => Promise.reject(e)) : res.json()).then(res => {\n      /*\n        whenever a logint is performed:\n        1. save the token in local storage\n        2. queue auto logout when the user goes idle\n        3. queue a call to the refresh endpoint based on the JWT's exp value\n      */\n      TokenService.saveAuthToken(res.authToken);\n      IdleService.regiserIdleTimerResets();\n      TokenService.queueCallbackBeforeExpiry(() => {\n        UserService.postRefreshToken();\n      });\n      return res;\n    });\n  },\n\n  postRefreshToken() {\n    return fetch(\"\".concat(API_BASE_URL, \"/auth/refresh\"), {\n      method: 'POST',\n      headers: {\n        'authorization': \"Bearer \".concat(TokenService.getAuthToken())\n      }\n    }).then(res => !res.ok ? res.json().then(e => Promise.reject(e)) : res.json()).then(res => {\n      /*\n        similar logic to whenever a user logs in, the only differences are:\n        - we don't need to queue the idle timers again as the user is already logged in.\n        - we'll catch the error here as this refresh is happening behind the scenes\n      */\n      TokenService.saveAuthToken(res.authToken);\n      TokenService.queueCallbackBeforeExpiry(() => {\n        UserService.postRefreshToken();\n      });\n      return res;\n    }).catch(err => {\n      console.log('refresh token request error');\n      console.error(err);\n    });\n  }\n\n};\nexport default UserService;","map":{"version":3,"sources":["C:/Users/t73de/Desktop/the console/src/services/user-service.js"],"names":["TokenService","IdleService","API_BASE_URL","UserService","postUser","user","fetch","method","headers","body","JSON","stringify","then","res","ok","json","e","Promise","reject","postLogin","username","password","saveAuthToken","authToken","regiserIdleTimerResets","queueCallbackBeforeExpiry","postRefreshToken","getAuthToken","catch","err","console","log","error"],"mappings":"AACA,OAAOA,YAAP,MAAyB,iBAAzB;AACA,OAAOC,WAAP,MAAwB,gBAAxB;AACA,SAASC,YAAT,QAA6B,WAA7B;AAEA,MAAMC,WAAW,GAAG;AAClBC,EAAAA,QAAQ,CAACC,IAAD,EAAO;AACb,WAAOC,KAAK,WAAIJ,YAAJ,aAA0B;AACpCK,MAAAA,MAAM,EAAE,MAD4B;AAEpCC,MAAAA,OAAO,EAAE;AACP,wBAAgB;AADT,OAF2B;AAKpCC,MAAAA,IAAI,EAAEC,IAAI,CAACC,SAAL,CAAeN,IAAf;AAL8B,KAA1B,CAAL,CAOJO,IAPI,CAOCC,GAAG,IACN,CAACA,GAAG,CAACC,EAAN,GACID,GAAG,CAACE,IAAJ,GAAWH,IAAX,CAAgBI,CAAC,IAAIC,OAAO,CAACC,MAAR,CAAeF,CAAf,CAArB,CADJ,GAEIH,GAAG,CAACE,IAAJ,EAVD,CAAP;AAYD,GAdiB;;AAelBI,EAAAA,SAAS,CAAC;AAAEC,IAAAA,QAAF;AAAYC,IAAAA;AAAZ,GAAD,EAAyB;AAChC,WAAOf,KAAK,WAAIJ,YAAJ,kBAA+B;AACzCK,MAAAA,MAAM,EAAE,MADiC;AAEzCC,MAAAA,OAAO,EAAE;AACP,wBAAgB;AADT,OAFgC;AAKzCC,MAAAA,IAAI,EAAEC,IAAI,CAACC,SAAL,CAAe;AAAES,QAAAA,QAAF;AAAYC,QAAAA;AAAZ,OAAf;AALmC,KAA/B,CAAL,CAOJT,IAPI,CAOCC,GAAG,IACN,CAACA,GAAG,CAACC,EAAN,GACID,GAAG,CAACE,IAAJ,GAAWH,IAAX,CAAgBI,CAAC,IAAIC,OAAO,CAACC,MAAR,CAAeF,CAAf,CAArB,CADJ,GAEIH,GAAG,CAACE,IAAJ,EAVD,EAYJH,IAZI,CAYCC,GAAG,IAAI;AACX;;;;;;AAMAb,MAAAA,YAAY,CAACsB,aAAb,CAA2BT,GAAG,CAACU,SAA/B;AACAtB,MAAAA,WAAW,CAACuB,sBAAZ;AACAxB,MAAAA,YAAY,CAACyB,yBAAb,CAAuC,MAAM;AAC3CtB,QAAAA,WAAW,CAACuB,gBAAZ;AACD,OAFD;AAGA,aAAOb,GAAP;AACD,KAzBI,CAAP;AA0BD,GA1CiB;;AA2ClBa,EAAAA,gBAAgB,GAAG;AACjB,WAAOpB,KAAK,WAAIJ,YAAJ,oBAAiC;AAC3CK,MAAAA,MAAM,EAAE,MADmC;AAE3CC,MAAAA,OAAO,EAAE;AACP,0CAA2BR,YAAY,CAAC2B,YAAb,EAA3B;AADO;AAFkC,KAAjC,CAAL,CAMJf,IANI,CAMCC,GAAG,IACN,CAACA,GAAG,CAACC,EAAN,GACID,GAAG,CAACE,IAAJ,GAAWH,IAAX,CAAgBI,CAAC,IAAIC,OAAO,CAACC,MAAR,CAAeF,CAAf,CAArB,CADJ,GAEIH,GAAG,CAACE,IAAJ,EATD,EAWJH,IAXI,CAWCC,GAAG,IAAI;AACX;;;;;AAKAb,MAAAA,YAAY,CAACsB,aAAb,CAA2BT,GAAG,CAACU,SAA/B;AACAvB,MAAAA,YAAY,CAACyB,yBAAb,CAAuC,MAAM;AAC3CtB,QAAAA,WAAW,CAACuB,gBAAZ;AACD,OAFD;AAGA,aAAOb,GAAP;AACD,KAtBI,EAuBJe,KAvBI,CAuBEC,GAAG,IAAI;AACZC,MAAAA,OAAO,CAACC,GAAR,CAAY,6BAAZ;AACAD,MAAAA,OAAO,CAACE,KAAR,CAAcH,GAAd;AACD,KA1BI,CAAP;AA2BD;;AAvEiB,CAApB;AA0EA,eAAe1B,WAAf","sourcesContent":["\nimport TokenService from './token-service'\nimport IdleService from './idle-service'\nimport { API_BASE_URL } from '../config'\n\nconst UserService = {\n  postUser(user) {\n    return fetch(`${API_BASE_URL}/users`, {\n      method: 'POST',\n      headers: {\n        'content-type': 'application/json',\n      },\n      body: JSON.stringify(user),\n    })\n      .then(res =>\n        (!res.ok)\n          ? res.json().then(e => Promise.reject(e))\n          : res.json()\n      )\n  },\n  postLogin({ username, password }) {\n    return fetch(`${API_BASE_URL}/auth/login`, {\n      method: 'POST',\n      headers: {\n        'content-type': 'application/json',\n      },\n      body: JSON.stringify({ username, password }),\n    })\n      .then(res =>\n        (!res.ok)\n          ? res.json().then(e => Promise.reject(e))\n          : res.json()\n      )\n      .then(res => {\n        /*\n          whenever a logint is performed:\n          1. save the token in local storage\n          2. queue auto logout when the user goes idle\n          3. queue a call to the refresh endpoint based on the JWT's exp value\n        */\n        TokenService.saveAuthToken(res.authToken)\n        IdleService.regiserIdleTimerResets()\n        TokenService.queueCallbackBeforeExpiry(() => {\n          UserService.postRefreshToken()\n        })\n        return res\n      })\n  },\n  postRefreshToken() {\n    return fetch(`${API_BASE_URL}/auth/refresh`, {\n      method: 'POST',\n      headers: {\n        'authorization': `Bearer ${TokenService.getAuthToken()}`,\n      },\n    })\n      .then(res =>\n        (!res.ok)\n          ? res.json().then(e => Promise.reject(e))\n          : res.json()\n      )\n      .then(res => {\n        /*\n          similar logic to whenever a user logs in, the only differences are:\n          - we don't need to queue the idle timers again as the user is already logged in.\n          - we'll catch the error here as this refresh is happening behind the scenes\n        */\n        TokenService.saveAuthToken(res.authToken)\n        TokenService.queueCallbackBeforeExpiry(() => {\n          UserService.postRefreshToken()\n        })\n        return res\n      })\n      .catch(err => {\n        console.log('refresh token request error')\n        console.error(err)\n      })\n  },\n}\n\nexport default UserService\n"]},"metadata":{},"sourceType":"module"}