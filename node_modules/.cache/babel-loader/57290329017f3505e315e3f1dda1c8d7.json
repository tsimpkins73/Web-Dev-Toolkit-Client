{"ast":null,"code":"import config from '../config';\nimport TokenService from './token-service';\nimport IdleService from './idle-service';\nconst AuthApiService = {\n  postUser(user) {\n    return fetch(\"\".concat(config.API_ENDPOINT, \"/users\"), {\n      method: 'POST',\n      headers: {\n        'content-type': 'application/json'\n      },\n      body: JSON.stringify(user)\n    }).then(res => !res.ok ? res.json().then(e => Promise.reject(e)) : res.json());\n  },\n\n  postLogin({\n    user_name,\n    password\n  }) {\n    return fetch(\"\".concat(config.API_ENDPOINT, \"/auth/login\"), {\n      method: 'POST',\n      headers: {\n        'content-type': 'application/json'\n      },\n      body: JSON.stringify({\n        user_name,\n        password\n      })\n    }).then(res => !res.ok ? res.json().then(e => Promise.reject(e)) : res.json()).then(res => {\n      /*\n        whenever a logint is performed:\n        1. save the token in local storage\n        2. queue auto logout when the user goes idle\n        3. queue a call to the refresh endpoint based on the JWT's exp value\n      */\n      TokenService.saveAuthToken(res.authToken);\n      IdleService.regiserIdleTimerResets();\n      TokenService.queueCallbackBeforeExpiry(() => {\n        AuthApiService.postRefreshToken();\n      });\n      return res;\n    });\n  },\n\n  postRefreshToken() {\n    return fetch(\"\".concat(config.API_ENDPOINT, \"/auth/refresh\"), {\n      method: 'POST',\n      headers: {\n        'authorization': \"Bearer \".concat(TokenService.getAuthToken())\n      }\n    }).then(res => !res.ok ? res.json().then(e => Promise.reject(e)) : res.json()).then(res => {\n      /*\n        similar logic to whenever a user logs in, the only differences are:\n        - we don't need to queue the idle timers again as the user is already logged in.\n        - we'll catch the error here as this refresh is happening behind the scenes\n      */\n      TokenService.saveAuthToken(res.authToken);\n      TokenService.queueCallbackBeforeExpiry(() => {\n        AuthApiService.postRefreshToken();\n      });\n      return res;\n    }).catch(err => {\n      console.log('refresh token request error');\n      console.error(err);\n    });\n  }\n\n};\nexport default AuthApiService;","map":{"version":3,"sources":["C:/Users/t73de/Desktop/the console/src/services/auth-api-service.js"],"names":["config","TokenService","IdleService","AuthApiService","postUser","user","fetch","API_ENDPOINT","method","headers","body","JSON","stringify","then","res","ok","json","e","Promise","reject","postLogin","user_name","password","saveAuthToken","authToken","regiserIdleTimerResets","queueCallbackBeforeExpiry","postRefreshToken","getAuthToken","catch","err","console","log","error"],"mappings":"AAAA,OAAOA,MAAP,MAAmB,WAAnB;AACA,OAAOC,YAAP,MAAyB,iBAAzB;AACA,OAAOC,WAAP,MAAwB,gBAAxB;AAEA,MAAMC,cAAc,GAAG;AACrBC,EAAAA,QAAQ,CAACC,IAAD,EAAO;AACb,WAAOC,KAAK,WAAIN,MAAM,CAACO,YAAX,aAAiC;AAC3CC,MAAAA,MAAM,EAAE,MADmC;AAE3CC,MAAAA,OAAO,EAAE;AACP,wBAAgB;AADT,OAFkC;AAK3CC,MAAAA,IAAI,EAAEC,IAAI,CAACC,SAAL,CAAeP,IAAf;AALqC,KAAjC,CAAL,CAOJQ,IAPI,CAOCC,GAAG,IACN,CAACA,GAAG,CAACC,EAAN,GACID,GAAG,CAACE,IAAJ,GAAWH,IAAX,CAAgBI,CAAC,IAAIC,OAAO,CAACC,MAAR,CAAeF,CAAf,CAArB,CADJ,GAEIH,GAAG,CAACE,IAAJ,EAVD,CAAP;AAYD,GAdoB;;AAerBI,EAAAA,SAAS,CAAC;AAAEC,IAAAA,SAAF;AAAaC,IAAAA;AAAb,GAAD,EAA0B;AACjC,WAAOhB,KAAK,WAAIN,MAAM,CAACO,YAAX,kBAAsC;AAChDC,MAAAA,MAAM,EAAE,MADwC;AAEhDC,MAAAA,OAAO,EAAE;AACP,wBAAgB;AADT,OAFuC;AAKhDC,MAAAA,IAAI,EAAEC,IAAI,CAACC,SAAL,CAAe;AAAES,QAAAA,SAAF;AAAaC,QAAAA;AAAb,OAAf;AAL0C,KAAtC,CAAL,CAOJT,IAPI,CAOCC,GAAG,IACN,CAACA,GAAG,CAACC,EAAN,GACID,GAAG,CAACE,IAAJ,GAAWH,IAAX,CAAgBI,CAAC,IAAIC,OAAO,CAACC,MAAR,CAAeF,CAAf,CAArB,CADJ,GAEIH,GAAG,CAACE,IAAJ,EAVD,EAYJH,IAZI,CAYCC,GAAG,IAAI;AACX;;;;;;AAMAb,MAAAA,YAAY,CAACsB,aAAb,CAA2BT,GAAG,CAACU,SAA/B;AACAtB,MAAAA,WAAW,CAACuB,sBAAZ;AACAxB,MAAAA,YAAY,CAACyB,yBAAb,CAAuC,MAAM;AAC3CvB,QAAAA,cAAc,CAACwB,gBAAf;AACD,OAFD;AAGA,aAAOb,GAAP;AACD,KAzBI,CAAP;AA0BD,GA1CoB;;AA2CrBa,EAAAA,gBAAgB,GAAG;AACjB,WAAOrB,KAAK,WAAIN,MAAM,CAACO,YAAX,oBAAwC;AAClDC,MAAAA,MAAM,EAAE,MAD0C;AAElDC,MAAAA,OAAO,EAAE;AACP,0CAA2BR,YAAY,CAAC2B,YAAb,EAA3B;AADO;AAFyC,KAAxC,CAAL,CAMJf,IANI,CAMCC,GAAG,IACN,CAACA,GAAG,CAACC,EAAN,GACID,GAAG,CAACE,IAAJ,GAAWH,IAAX,CAAgBI,CAAC,IAAIC,OAAO,CAACC,MAAR,CAAeF,CAAf,CAArB,CADJ,GAEIH,GAAG,CAACE,IAAJ,EATD,EAWJH,IAXI,CAWCC,GAAG,IAAI;AACX;;;;;AAKAb,MAAAA,YAAY,CAACsB,aAAb,CAA2BT,GAAG,CAACU,SAA/B;AACAvB,MAAAA,YAAY,CAACyB,yBAAb,CAAuC,MAAM;AAC3CvB,QAAAA,cAAc,CAACwB,gBAAf;AACD,OAFD;AAGA,aAAOb,GAAP;AACD,KAtBI,EAuBJe,KAvBI,CAuBEC,GAAG,IAAI;AACZC,MAAAA,OAAO,CAACC,GAAR,CAAY,6BAAZ;AACAD,MAAAA,OAAO,CAACE,KAAR,CAAcH,GAAd;AACD,KA1BI,CAAP;AA2BD;;AAvEoB,CAAvB;AA0EA,eAAe3B,cAAf","sourcesContent":["import config from '../config'\nimport TokenService from './token-service'\nimport IdleService from './idle-service'\n\nconst AuthApiService = {\n  postUser(user) {\n    return fetch(`${config.API_ENDPOINT}/users`, {\n      method: 'POST',\n      headers: {\n        'content-type': 'application/json',\n      },\n      body: JSON.stringify(user),\n    })\n      .then(res =>\n        (!res.ok)\n          ? res.json().then(e => Promise.reject(e))\n          : res.json()\n      )\n  },\n  postLogin({ user_name, password }) {\n    return fetch(`${config.API_ENDPOINT}/auth/login`, {\n      method: 'POST',\n      headers: {\n        'content-type': 'application/json',\n      },\n      body: JSON.stringify({ user_name, password }),\n    })\n      .then(res =>\n        (!res.ok)\n          ? res.json().then(e => Promise.reject(e))\n          : res.json()\n      )\n      .then(res => {\n        /*\n          whenever a logint is performed:\n          1. save the token in local storage\n          2. queue auto logout when the user goes idle\n          3. queue a call to the refresh endpoint based on the JWT's exp value\n        */\n        TokenService.saveAuthToken(res.authToken)\n        IdleService.regiserIdleTimerResets()\n        TokenService.queueCallbackBeforeExpiry(() => {\n          AuthApiService.postRefreshToken()\n        })\n        return res\n      })\n  },\n  postRefreshToken() {\n    return fetch(`${config.API_ENDPOINT}/auth/refresh`, {\n      method: 'POST',\n      headers: {\n        'authorization': `Bearer ${TokenService.getAuthToken()}`,\n      },\n    })\n      .then(res =>\n        (!res.ok)\n          ? res.json().then(e => Promise.reject(e))\n          : res.json()\n      )\n      .then(res => {\n        /*\n          similar logic to whenever a user logs in, the only differences are:\n          - we don't need to queue the idle timers again as the user is already logged in.\n          - we'll catch the error here as this refresh is happening behind the scenes\n        */\n        TokenService.saveAuthToken(res.authToken)\n        TokenService.queueCallbackBeforeExpiry(() => {\n          AuthApiService.postRefreshToken()\n        })\n        return res\n      })\n      .catch(err => {\n        console.log('refresh token request error')\n        console.error(err)\n      })\n  },\n}\n\nexport default AuthApiService\n"]},"metadata":{},"sourceType":"module"}